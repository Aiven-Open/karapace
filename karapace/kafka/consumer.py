"""
Copyright (c) 2023 Aiven Ltd
See LICENSE for details
"""

from __future__ import annotations

from confluent_kafka import Consumer, TopicPartition
from confluent_kafka.admin import PartitionMetadata
from confluent_kafka.error import KafkaException
from kafka.errors import KafkaTimeoutError
from karapace.kafka.common import _KafkaConfigMixin, KafkaClientParams, raise_from_kafkaexception
from typing import Iterable
from typing_extensions import Unpack

import secrets


class KafkaConsumer(_KafkaConfigMixin, Consumer):
    def __init__(
        self,
        topic: str,
        bootstrap_servers: Iterable[str] | str,
        verify_connection: bool = True,
        **params: Unpack[KafkaClientParams],
    ) -> None:
        # The `confluent_kafka.Consumer` does not allow for a missing group id
        # if the client of this class does not provide one, we'll generate a
        # unique group id to achieve the groupless behaviour
        if "group_id" not in params:
            params["group_id"] = self._create_group_id()

        super().__init__(bootstrap_servers, verify_connection, **params)

        self.subscribe([topic])

    @staticmethod
    def _create_group_id() -> str:
        return f"karapace-autogenerated-{secrets.token_hex(6)}"

    def partitions_for_topic(self, topic: str) -> dict[int, PartitionMetadata]:
        """Returns all partition metadata for the given topic."""
        try:
            return self.list_topics(topic).topics[topic].partitions
        except KafkaException as exc:
            raise_from_kafkaexception(exc)

    def get_watermark_offsets(
        self, partition: TopicPartition, timeout: float | None = None, cached: bool = False
    ) -> tuple[int, int]:
        """Wrapper around `Consumer.get_watermark_offsets` to handle error cases and exceptions.

        confluent-kafka is somewhat inconsistent with error-related behaviours,
        `get_watermark_offsets` returns `None` on timeouts, so we are translating it to an
        exception.
        """
        try:
            if timeout is not None:
                result = super().get_watermark_offsets(partition, timeout, cached)
            else:
                result = super().get_watermark_offsets(partition, cached=cached)

            if result is None:
                raise KafkaTimeoutError()

            return result
        except KafkaException as exc:
            raise_from_kafkaexception(exc)
